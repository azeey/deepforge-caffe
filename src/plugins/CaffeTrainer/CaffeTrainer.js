/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Sun Nov 15 2015 08:25:24 GMT-0600 (CST).
 */

define([
    'plugin/PluginConfig',
    'plugin/CaffeGenerator/CaffeGenerator/CaffeGenerator',
    'executor/ExecutorClient'
], function (
    PluginConfig,
    CaffeGenerator,
    ExecutorClient
) {
    'use strict';

    // Define fixed parameters of the config:
    //  + Input data
    //  + Data source type?
    //  + Display iterations
    //  + snapshot
    //  + snapshot prefix
    var CONFIG_CONSTANTS = 
        {
            dataType: 'LMDB',
            inputData: 'NONE',
            display: 500,
            snapshot: 10000000,  // No snapshots -> just the last result!
            snapshotPrefix: 'snapshot_'
        },
        TEMPLATE_SUFFIX = 'classify.prototxt.ejs';

    /**
     * Initializes a new instance of CaffeTrainer.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CaffeTrainer.
     * @constructor
     */
    var CaffeTrainer = function () {
        // Call base class' constructor.
        CaffeGenerator.call(this);
    };

    // Prototypal inheritance from PluginBase.
    CaffeTrainer.prototype = Object.create(CaffeGenerator.prototype);
    CaffeTrainer.prototype.constructor = CaffeTrainer;

    /**
     * Gets the name of the CaffeTrainer.
     * @returns {string} The name of the plugin.
     * @public
     */
    CaffeTrainer.prototype.getName = function () {
        return 'CaffeTrainer';
    };

    /**
     * Gets the semantic version (semver.org) of the CaffeTrainer.
     * @returns {string} The version of the plugin.
     * @public
     */
    CaffeTrainer.prototype.getVersion = function () {
        return '0.1.0';
    };

    CaffeTrainer.prototype.getConfigStructure = function () {
        var baseConfig = CaffeGenerator.prototype.getConfigStructure.call(this);
        // Remove fixed parameters
        return baseConfig
            .filter(function(opt) {
                return !CONFIG_CONSTANTS[opt.name];
            });
    };

    CaffeTrainer.prototype.main = function (callback) {
        var config = this.getCurrentConfig();

        // Set the fixed values
        Object.keys(CONFIG_CONSTANTS).forEach(function(key) {
            config[key] = CONFIG_CONSTANTS[key];
        });
        CaffeGenerator.prototype.main.call(this, callback);
    };

    CaffeTrainer.prototype.beforePrototxtGeneration = function (callback) {
        // Set the inputData value to the name of the data object (w/o the extension)
        var self = this,
            config = this.getCurrentConfig();

        self.getDataNode(function(e, dataNode) {
            var dataHash;

            if (e) {
                return callback(e);
            }
            dataHash = self.core.getAttribute(dataNode, 'data');
            self.blobClient.getMetadata(dataHash, function(err, metadata) {
                if (err) {
                    return callback(err);
                }

                // Set the inputData in the config to the file name
                config.inputData = metadata.name.replace('.zip', '');
                callback();
            });
        });
    };

    // Override from CaffeGenerator
    // Train the model
    CaffeTrainer.prototype._saveOutput = function (name, files, callback) {
        var self = this,
            artifact,
            executorConfig,
            metadata = JSON.parse(files.metadata),
            shellScript = 'train_net.sh';

        executorConfig = {
            cmd: 'bash',
                                   // Make sure no arguments are here, put them in args
            args: [shellScript],
            resultArtifacts: [ // These are the results that will be returned
                {
                    name: 'all',
                    resultPatterns: []
                },
                {
                    name: 'models',
                    resultPatterns: ['**/*caffemodel']
                },
                {
                    name: 'solverstates',
                    resultPatterns: ['**/*solverstate']
                }
            ]
        };
        files['executor_config.json'] = JSON.stringify(executorConfig, null, 4);
        this.addDataFromBlob(files, function(e, zipName) {
            if (e) {
                return callback(e, self.result);
            }
            // Add shell execution script
            files[shellScript] = 'unzip ' + zipName + ' && ' + metadata.trainCommand;

            artifact = self.blobClient.createArtifact('executionFiles');

            artifact.addFiles(files, function (err) {
                if (err) {
                    callback(err, self.result);
                    return;
                }
                self.logger.info('added files');
                artifact.save(function (err, hash) {
                    if (err) {
                        callback(err, self.result);
                        return;
                    }
                    self.logger.info('artifact saved');
                    self.result.addArtifact(hash);
                    self.revert();  // Remove modified model from CaffeGenerator
                    self.createTrainedNode(files, function(err) {
                        if (err) {
                            return callback(err);
                        }

                        self.executeJob(hash, callback);
                    });
                });
            });
        });
    };

    // Retrieve the zipped data files from the blob and add them to the executor
    // files
    CaffeTrainer.prototype.addDataFromBlob = function(files, callback) {
        // Get the data node
        var self = this;

        self.getDataNode(function(e, dataNode) {
            var dataHash,
                name;

            if (e) {
                return callback(e);
            }

            // Get the data zip file
            dataHash = self.core.getAttribute(dataNode, 'data');
            self.blobClient.getObject(dataHash, function(err, arrayBuffer) {
                // Add it to the "files" object by name
                if (err) {
                    return callback(err);
                }

                name = self.core.getAttribute(dataNode, 'name') + '.zip';
                files[name] = arrayBuffer;
                callback(null, name);
            });
        });
    };

    CaffeTrainer.prototype.getDataNode = function(callback) {
        var self = this;
        self.core.loadChildren(self.activeNode, function(e, children) {
            var dataNodes,
                dataNode,
                dataHash,
                name;

            if (e) {
                return callback(e);
            }
            dataNodes = children.filter(function(child) {
                return self.isMetaTypeOf(child, self.META.DataBase);
            });

            if (dataNodes.length > 1) {
                return callback('Multiple data nodes detected. This is not currently supported');
            }

            dataNode = dataNodes[0];
            callback(null, dataNode);
        });
    };

    CaffeTrainer.prototype.executeJob = function(hash, callback) {
        var self = this,
            executorClient;

        executorClient = new ExecutorClient({
            //httpsecure: self.gmeConfig.server.https.enable,
            serverPort: self.gmeConfig.server.port
        });
        self.logger.info('created new ExecutorClient instance');
        // Here the hash of the artifact is passed to the new job.
        executorClient.createJob({hash: hash}, function (err, jobInfo) {
            var intervalID;
            if (err) {
                callback('Creating job failed: ' + err.toString(), self.result);
                return;
            }
            self.logger.info('job created');
            self.logger.debug(jobInfo);
            // This will be called after a succeed job

            intervalID = setInterval(function () {
                // Get the job-info at intervals and check for a non-CREATED/RUNNING status.
                executorClient.getInfo(hash, function (err, jInfo) {
                    var key;
                    self.logger.info(JSON.stringify(jInfo, null, 4));
                    if (jInfo.status === 'CREATED' || jInfo.status === 'RUNNING') {
                        // The job is still running..
                        return;
                    }

                    clearInterval(intervalID);
                    if (jInfo.status === 'SUCCESS') {
                        self.atSucceedJob(jInfo, callback);
                    } else {
                        //Add the resultHashes even though job failed (for user to debug).
                        for (key in jInfo.resultHashes) {
                            if (jInfo.resultHashes.hasOwnProperty(key)) {
                                self.result.addArtifact(jInfo.resultHashes[key]);
                            }
                        }
                        callback('Job execution failed', self.result);
                    }
                });
            }, 400);
        });

    };

    CaffeTrainer.prototype.atSucceedJob = function(jInfo, callback) {
        var self = this,
            modelHash;

        // resultHashes
        this.result.addArtifact(jInfo.resultHashes.all);
        
        modelHash = jInfo.resultHashes.models;
        this.core.setAttribute(this.modelNode, 'model', modelHash);

        this.save('Created model at: '+name, function (err) {
            self.result.setSuccess(!err);
            callback(err, self.result);
        });
    };

    CaffeTrainer.prototype.createTrainedNode = function(files, callback) {
        var self = this;

        self.getModelsDir(function(e, modelsDir) {
            // Create the trained model node and attach the trained model to it
            if (e || !modelsDir) {
                return callback(e || 'Models directory not found');
            }
            self.modelNode = self.core.createNode({
                parent: modelsDir,
                base: self.META.Model
            });

            // Set an intelligent model name FIXME
            self.core.setAttribute(self.modelNode, 'name', 'TrainedModel');

            // Set the prototxt template
            self.savePrototxtAlone(files, function(err, hash) {
                self.core.setAttribute(self.modelNode, 'prototxt', hash);
                callback(null);
            });
        });
    };

    CaffeTrainer.prototype.savePrototxtAlone = function(files, callback) {
        let names = Object.keys(files),
            templateName,
            artifact;

        for (var i = names.length; i--;) {
            if (names[i].indexOf(TEMPLATE_SUFFIX) !== -1) {
                templateName = names[i];
            }
        }

        // Save the prototxt template in the blob and store the hash
        this.blobClient.putFile(templateName, files[templateName], callback);
    };

    CaffeTrainer.prototype.getModelsDir = function(callback) {
        var self = this,
            modelsDir;

        this.core.loadChildren(this.rootNode, function(e, children) {
            if (e) {
                return callback(e);
            }
            modelsDir = children.filter(function(child) {
                return self.core.getAttribute(child, 'name').toLowerCase() === 'models';
            })[0];
            callback(null, modelsDir);
        });
    };

    return CaffeTrainer;
});
