/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Tue Dec 22 2015 06:15:18 GMT-0600 (CST).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'executor/ExecutorClient',
    '../common/Constants',
    'text!./resources/classify.py'
], function (
    PluginConfig,
    PluginBase,
    ExecutorClient,
    Constants,
    CLASSIFY_PY
) {
    'use strict';

    /**
     * Initializes a new instance of CaffeClassifier.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin CaffeClassifier.
     * @constructor
     */
    var CaffeClassifier = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    CaffeClassifier.prototype = Object.create(PluginBase.prototype);
    CaffeClassifier.prototype.constructor = CaffeClassifier;

    /**
     * Gets the name of the CaffeClassifier.
     * @returns {string} The name of the plugin.
     * @public
     */
    CaffeClassifier.prototype.getName = function () {
        return 'CaffeClassifier';
    };

    /**
     * Gets the semantic version (semver.org) of the CaffeClassifier.
     * @returns {string} The version of the plugin.
     * @public
     */
    CaffeClassifier.prototype.getVersion = function () {
        return '0.1.0';
    };

    CaffeClassifier.prototype.getConfigStructure = function(){
        return [
            // FIXME: Detect the dimensions of the input
            {  // dims of the input
                name: 'dims',
                displayName: 'Input Dimensions',
                description: '',
                value: '64x1x28x28',
                valueType: 'string',
                readOnly: false
            },
            {  // images to classify
                name: 'image',  // TODO: add support for multiple images
                displayName: 'Image to Classify',
                description: '',
                value: '',
                valueType: 'asset',
                readOnly: false
            }
        ];
    }

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    CaffeClassifier.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this;

        // Verify that we are on the correct node type
        // TODO

        // Change underscorejs tags to handlebar style
        _.templateSettings = {
            interpolate: /\{\{=(.+?)\}\}/g,
            evaluate: /\{\{(.+?)\}\}/g,
        };

        // Pack all files for executor
        this.createExecutorFiles((err, hash) => {
            if (err) {
                return callback(err, this.result);
            }

            // Can I do this without downloading and re-uploading the files?
            // TODO

            // Create the executor job
            this.logger.debug('Created executor files!');
            this.executeJob(hash, callback);
        });
    };

    CaffeClassifier.prototype.MODEL_NAME = 'model.caffemodel';
    CaffeClassifier.prototype.PROTO_NAME = 'network.prototxt';
    CaffeClassifier.prototype.IMAGE_NAME = 'image.png';
    CaffeClassifier.prototype.createExecutorFiles = function (callback) {
        var files = {},
            executorConfig;

        // Get the trained model
        this.getTrainedModel((err, model) => {
            if (err) {
                return callback(err, this.result);
            }
            files[this.MODEL_NAME] = model;

            this.addExecutionFiles(files, (err) => {
                var artifact;
                if (err) {
                    return callback(err, this.result);
                }

                executorConfig = this.getExecutorConfig();
                files['executor_config.json'] = JSON.stringify(executorConfig, null, 2);

                artifact = this.blobClient.createArtifact('classificationFiles');
                this.logger.debug('Adding files: ' + Object.keys(files)
                        .map(name => '"' + name + '"').join(','));

                // Add hashes
                // TODO

                // Add files by content
                artifact.addFiles(files, (err) => {
                    if (err) {
                        return callback(err, this.result);
                    }

                    this.logger.debug('Added classification files to blob');
                    artifact.save(callback);
                });
            });
        });
    };

    CaffeClassifier.prototype.getExecutorConfig = function (callback) {
        return {
            cmd: 'python2',
            args: ['classify.py', this.PROTO_NAME, this.MODEL_NAME, this.IMAGE_NAME],
            resultArtifacts: [
                {
                    name: 'all',
                    resultPatterns: []
                },
                {
                    name: 'predictions',
                    resultPatterns: ['predictions.txt']
                }
            ]
        };
    };

    CaffeClassifier.prototype.getImage = function (callback) {
        var imageHash = this.getCurrentConfig().image;

        this.blobClient.getObject(imageHash, callback);
    };

    // Should I change this so the models are webgme objects?
    // TODO
    CaffeClassifier.prototype.getTrainedModel = function (callback) {
        var modelHash = this.core.getAttribute(this.activeNode, 'model');

        // Select the model to use from the available snapshots
        this.blobClient.getMetadata(modelHash, (err, metadata) => {
            let models,
                modelName,
                hash;

            if (err) {
                return callback(err, this.result);
            }

            models = Object.keys(metadata.content);
            // Choose the model by the largest iteration
            modelName = this.selectModelName(models),
            hash = metadata.content[modelName].content;

            this.blobClient.getObject(hash, callback);
        });
    };

    CaffeClassifier.prototype.selectModelName = function (models) {
        var numbers = /\d+/,
            match,
            i;

        return models
            .map(name => {  // Get the iteration number
                match = name.match(numbers);
                i = match ? +match[0] : 0;
                return [name, i];
            })
            .sort((a, b) => a[1] > b[1])
            .shift()[0];
    };

    CaffeClassifier.prototype.addExecutionFiles = function (files, callback) {
        var prototxtHash = this.core.getAttribute(this.activeNode, 'classify'),
            prototxtTemplate,
            prototxt;

        this.blobClient.getObject(prototxtHash, (err, arrayBuffer) => {
            if (err) {
                return callback(err);
            }

            prototxtTemplate = String.fromCharCode.apply(null, new Uint8Array(arrayBuffer));
            // Populate it with the config settings
            prototxt = this.createNetPrototxt(prototxtTemplate);

            this.logger.debug('Created the classification protoxt');

            this.getImage((err, image) => {
                // Add prototxt and python script to files
                files[this.IMAGE_NAME] = image;
                files[this.PROTO_NAME] = prototxt;
                files['classify.py'] = CLASSIFY_PY;
                callback(null);
            });
        });
    };

    CaffeClassifier.prototype.createNetPrototxt = function (template) {
        var dataLayer = `input: "${Constants.DATA_LAYER_NAME}"`;
        dataLayer += _.template([
            'input_shape {',
            '{{ _.each(dims, function(dim) { }}',
            '  dim: {{= dim }}{{ }); }}',
            '}\n'
        ].join('\n'))({
            dims: this.getCurrentConfig().dims.split(/[^\d]+/g)
        });

        return _.template(prototxtTemplate)({dataLayer});
    };

    CaffeClassifier.prototype.executeJob = function(hash, callback) {
        var self = this,
            executorClient;

        this.result.addArtifact(hash);
        executorClient = new ExecutorClient({
            serverPort: self.gmeConfig.server.port
        });
        self.logger.info('created new ExecutorClient instance');
        // Here the hash of the artifact is passed to the new job.
        executorClient.createJob({hash: hash}, function (err, jobInfo) {
            var intervalID;
            if (err) {
                callback('Creating job failed: ' + err.toString(), self.result);
                return;
            }
            self.logger.info('job created');
            self.logger.debug(jobInfo);
            // This will be called after a succeed job

            intervalID = setInterval(function () {
                // Get the job-info at intervals and check for a non-CREATED/RUNNING status.
                executorClient.getInfo(hash, function (err, jInfo) {
                    var key;
                    self.logger.info(JSON.stringify(jInfo, null, 4));
                    if (jInfo.status === 'CREATED' || jInfo.status === 'RUNNING') {
                        // The job is still running..
                        return;
                    }

                    clearInterval(intervalID);
                    if (jInfo.status === 'SUCCESS') {
                        self.onJobSuccess(jInfo, callback);
                    } else {
                        //Add the resultHashes even though job failed (for user to debug).
                        for (key in jInfo.resultHashes) {
                            if (jInfo.resultHashes.hasOwnProperty(key)) {
                                self.result.addArtifact(jInfo.resultHashes[key]);
                            }
                        }
                        callback('Job execution failed', self.result);
                    }
                });
            }, 400);
        });

    };

    CaffeClassifier.prototype.onJobSuccess = function (jInfo, callback) {
        this.logger.debug('Classification job successful');
        // Get the label(s) and add it to the artifact
        // I guess I could make it a message if there is just one
        this.result.addArtifact(jInfo.resultHashes.all);

        // Read the predictions and set the messages accordingly
        this.getPredictions(jInfo.resultHashes.predictions, (err, preds) => {
            if (err) {
                return callback(err);
            }

            // FIXME: This approach will not work for large amounts of images
            for (var i = preds.length; i--;) {
                this.createMessage(null, `${preds[i][0]} belongs to ${preds[i][1]}`);
            }
            this.result.setSuccess(true);
            callback(null, this.result);
        });
    };

    CaffeClassifier.prototype.getPredictions = function (hash, callback) {
        this.blobClient.getMetadata(hash, (err, metadata) => {
            let files = Object.keys(metadata.content),  // Should only be one
                predFileHash = metadata.content[files[0]].content;

            this.blobClient.getObject(predFileHash, (err, array) => {
                let content,
                    predictions;

                if (err) {
                    return callback(err);
                }
                content = String.fromCharCode.apply(null, new Uint8Array(array));
                predictions = content
                    .split('\n')
                    .filter(line => line.indexOf('\t') !== -1)
                    .map(line => line.split('\t'));

                return callback(null, predictions);
            });
        });

    };

    return CaffeClassifier;
});
